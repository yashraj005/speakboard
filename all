Pizza parlor

import java.util.Scanner;

public class PizzaParlour {

    private int front, rear, size;
    private int[] queue;
    
    public PizzaParlour(int N) {
        size = N;
        queue = new int[size];
        front = -1;
        rear = -1;
    }

    public boolean isFull() {
        return (front == 0 && rear == size - 1) || (front == rear + 1);
    }

    public boolean isEmpty() {
        return front == -1;
    }

    public void placeOrder(int order) {
        if (isFull()) {
            System.out.println("Order queue is full. Cannot place more orders.");
        } else {
            if (front == -1) {
                front = 0;
            }
            rear = (rear + 1) % size;
            queue[rear] = order;
            System.out.println("Order " + order + " placed.");
        }
    }

    public void serveOrder() {
        if (isEmpty()) {
            System.out.println("No orders to serve.");
        } else {
            System.out.println("Order " + queue[front] + " served.");
            if (front == rear) {
                front = -1;
                rear = -1;
            } else {
                front = (front + 1) % size;
            }
        }
    }

    public void displayOrders() {
        if (isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            System.out.print("Current orders: ");
            int i = front;
            while (i != rear) {
                System.out.print(queue[i] + " ");
                i = (i + 1) % size;
            }
            System.out.println(queue[rear]);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter maximum number of orders (N): ");
        int N = scanner.nextInt();
        PizzaParlour pizzaParlour = new PizzaParlour(N);

        int choice;
        do {
            System.out.println("\nMenu: ");
            System.out.println("1. Place Order");
            System.out.println("2. Serve Order");
            System.out.println("3. Display Orders");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter order number: ");
                    int order = scanner.nextInt();
                    pizzaParlour.placeOrder(order);
                    break;

                case 2:
                    pizzaParlour.serveOrder();
                    break;

                case 3:
                    pizzaParlour.displayOrders();
                    break;

                case 4:
                    System.out.println("Exiting...");
                    break;

                default:
                    System.out.println("Invalid choice! Please choose again.");
            }
        } while (choice != 4);

        scanner.close();
    }
}

Threaded binary tree
package Assignment5;

import java.util.Scanner;

class Node {
    int data;
    Node left, right;
    boolean leftThread, rightThread;

    Node(int data) {
        this.data = data;
        this.left = this.right = null;
        this.leftThread = this.rightThread = false;
    }
}

class ThreadedBinaryTree {
    private Node root;

    public void insert(int data) {
        Node newNode = new Node(data);
        if (root == null) {
            root = newNode;
            return;
        }

        Node parent = null;
        Node current = root;

        while (current != null) {
            parent = current;
            if (data < current.data) {
                if (!current.leftThread) {
                    current = current.left;
                } else {
                    break;
                }
            } else {
                if (!current.rightThread) {
                    current = current.right;
                } else {
                    break;
                }
            }
        }

        if (data < parent.data) {
            newNode.left = parent.left;
            newNode.right = parent;
            parent.leftThread = false;
            parent.left = newNode;
        } else {
            newNode.right = parent.right;
            newNode.left = parent;
            parent.rightThread = false;
            parent.right = newNode;
        }
    }

    public void inorder() {
        if (root == null) {
            System.out.println("Tree is empty.");
            return;
        }

        Node current = root;
        while (!current.leftThread) {
            current = current.left;
        }

        while (current != null) {
            System.out.print(current.data + " ");
            if (current.rightThread) {
                current = current.right;                  
            } else {
                current = current.right;
                while (current != null && !current.leftThread) {
                    current = current.left;
                }
            }
        }
        System.out.println();
    }
}

public class ThreadedBinaryTreeApp {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ThreadedBinaryTree tbt = new ThreadedBinaryTree();
        int choice, data;

        while (true) {
            System.out.println("Menu:");
            System.out.println("1. Insert");
            System.out.println("2. Inorder Traversal");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter data to insert: ");
                    data = scanner.nextInt();
                    tbt.insert(data);
                    break;
                case 2:
                    tbt.inorder();
                    break;
                case 3:
                scanner.close();
                return;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }

       
    }
}
Transport netwoek
import java.util.*;

class Edge {
    int source, destination, weight;

    Edge(int source, int destination, int weight) {
        this.source = source;
        this.destination = destination;
        this.weight = weight;
    }
}

class Graph {
    int vertices;
    List<Edge> edges;

    Graph(int vertices) {
        this.vertices = vertices;
        edges = new ArrayList<>();
    }

    void addEdge(int source, int destination, int weight) {
        edges.add(new Edge(source, destination, weight));
    }

    void primMST() {
        boolean[] inMST = new boolean[vertices];
        Edge[] result = new Edge[vertices - 1];
        int edgeCount = 0;
        int totalCost = 0;
        inMST[0] = true;

        while (edgeCount < vertices - 1) {
            int minWeight = Integer.MAX_VALUE;
            Edge minEdge = null;

            for (Edge edge : edges) {
                if (inMST[edge.source] != inMST[edge.destination]) {
                    if (edge.weight < minWeight) {
                        minWeight = edge.weight;
                        minEdge = edge;
                    }
                }
            }

            if (minEdge != null) {
                result[edgeCount++] = minEdge;
                totalCost += minEdge.weight;
                inMST[minEdge.source] = true;
                inMST[minEdge.destination] = true;
            }
        }

        System.out.println("Minimum Spanning Tree edges:");
        for (Edge edge : result) {
            System.out.println("City " + edge.source + " - City " + edge.destination + " : " + edge.weight);
        }
        System.out.println("Total cost: " + totalCost);
    }
}

public class TransportationNetwork {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Graph graph = null;
        int choice;

        while (true) {
            System.out.println("Menu:");
            System.out.println("1. Create Graph");
            System.out.println("2. Add Edge");
            System.out.println("3. Calculate Minimum Spanning Tree (MST)");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter number of cities: ");
                    int cities = scanner.nextInt();
                    graph = new Graph(cities);
                    System.out.println("Graph created with " + cities + " cities.");
                    break;
                case 2:
                    if (graph == null) {
                        System.out.println("Graph not created yet.");
                        break;
                    }
                    System.out.print("Enter source city, destination city, and weight: ");
                    int source = scanner.nextInt();
                    int destination = scanner.nextInt();
                    int weight = scanner.nextInt();
                    graph.addEdge(source, destination, weight);
                    System.out.println("Edge added.");
                    break;
                case 3:
                    if (graph == null) {
                        System.out.println("Graph not created yet.");
                        break;
                    }
                    graph.primMST();
                    break;
                case 4:
                    scanner.close();
                    return;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}

delivery locations

import java.util.*;

class CourierService {

    private int vertices;
    private int[][] adjMatrix;

    public CourierService(int vertices) {
        this.vertices = vertices;
        adjMatrix = new int[vertices][vertices];
        for (int i = 0; i < vertices; i++) {
            Arrays.fill(adjMatrix[i], Integer.MAX_VALUE);
            adjMatrix[i][i] = 0;
        }
    }

    public void addRoad(int source, int destination, int distance) {
        adjMatrix[source][destination] = distance;
        adjMatrix[destination][source] = distance;
    }

    public void dijkstra(int startVertex) {
        boolean[] visited = new boolean[vertices];
        int[] distances = new int[vertices];
        Arrays.fill(distances, Integer.MAX_VALUE);
        distances[startVertex] = 0;

        for (int i = 0; i < vertices; i++) {
            int u = getMinimumDistanceVertex(visited, distances);
            visited[u] = true;

            for (int v = 0; v < vertices; v++) {
                if (!visited[v] && adjMatrix[u][v] != Integer.MAX_VALUE && distances[u] != Integer.MAX_VALUE &&
                    distances[u] + adjMatrix[u][v] < distances[v]) {
                    distances[v] = distances[u] + adjMatrix[u][v];
                }
            }
        }

        printSolution(distances, startVertex);
    }

    private int getMinimumDistanceVertex(boolean[] visited, int[] distances) {
        int minDistance = Integer.MAX_VALUE;
        int minIndex = -1;

        for (int v = 0; v < vertices; v++) {
            if (!visited[v] && distances[v] < minDistance) {
                minDistance = distances[v];
                minIndex = v;
            }
        }

        return minIndex;
    }

    public void floydWarshall() {
        int[][] dist = new int[vertices][vertices];

        for (int i = 0; i < vertices; i++) {
            System.arraycopy(adjMatrix[i], 0, dist[i], 0, vertices);
        }

        for (int k = 0; k < vertices; k++) {
            for (int i = 0; i < vertices; i++) {
                for (int j = 0; j < vertices; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        printAllPairsShortestPaths(dist);
    }

    private void printSolution(int[] distances, int startVertex) {
        System.out.println("Shortest distances from location " + startVertex + ":");
        for (int i = 0; i < distances.length; i++) {
            System.out.println("To location " + i + " - Distance: " + distances[i]);
        }
    }

    private void printAllPairsShortestPaths(int[][] dist) {
        System.out.println("All pairs shortest paths:");
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                if (dist[i][j] == Integer.MAX_VALUE) {
                    System.out.print("INF ");
                } else {
                    System.out.print(dist[i][j] + " ");
                }
            }
            System.out.println();
        }
    }
}

public class CourierServiceApp {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        CourierService service = null;
        int choice;

        while (true) {
            System.out.println("Menu:");
            System.out.println("1. Create City Map");
            System.out.println("2. Add Road");
            System.out.println("3. Find Shortest Path (Dijkstra)");
            System.out.println("4. Find All Pairs Shortest Paths (Floyd-Warshall)");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter number of locations: ");
                    int locations = scanner.nextInt();
                    service = new CourierService(locations);
                    System.out.println("City map created with " + locations + " locations.");
                    break;
                case 2:
                    if (service == null) {
                        System.out.println("City map not created yet.");
                        break;
                    }
                    System.out.print("Enter source location, destination location, and distance: ");
                    int source = scanner.nextInt();
                    int destination = scanner.nextInt();
                    int distance = scanner.nextInt();
                    service.addRoad(source, destination, distance);
                    System.out.println("Road added.");
                    break;
                case 3:
                    if (service == null) {
                        System.out.println("City map not created yet.");
                        break;
                    }
                    System.out.print("Enter starting location: ");
                    int startLocation = scanner.nextInt();
                    service.dijkstra(startLocation);
                    break;
                case 4:
                    if (service == null) {
                        System.out.println("City map not created yet.");
                        break;
                    }
                    service.floydWarshall();
                    break;
                case 5:
                    scanner.close();
                    return;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}


Hash table

package Assignment10;

import java.util.LinkedList;
import java.util.Scanner;

class UserProfile {
    String username;
    String post;
    String comment;
    String preference;

    public UserProfile(String username, String post, String comment, String preference) {
        this.username = username;
        this.post = post;
        this.comment = comment;
        this.preference = preference;
    }

    @Override
    public String toString() {
        return "Username: " + username + "\nPost: " + post + "\nComment: " + comment + "\nPreference: " + preference;
    }
}

class HashTable {
    private int TABLE_SIZE = 10;
    private LinkedList<UserProfile>[] table;

    public HashTable() {
        table = new LinkedList[TABLE_SIZE];
        for (int i = 0; i < TABLE_SIZE; i++) {
            table[i] = new LinkedList<>();
        }
    }

    private int hashFunction(String key) {
        int hashCode = 0;
        for (char c : key.toCharArray()) {
            hashCode += c;
        }
        return hashCode % TABLE_SIZE;
    }

    public void addProfile(UserProfile profile) {
        int index = hashFunction(profile.username);
        table[index].add(profile);
    }

    public UserProfile getProfile(String username) {
        int index = hashFunction(username);
        for (UserProfile profile : table[index]) {
            if (profile.username.equals(username)) {
                return profile;
            }
        }
        return null;
    }

    public void updateProfile(String username, String post, String comment, String preference) {
        UserProfile profile = getProfile(username);
        if (profile != null) {
            profile.post = post;
            profile.comment = comment;
            profile.preference = preference;
        }
    }

    public void deleteProfile(String username) {
        int index = hashFunction(username);
        table[index].removeIf(profile -> profile.username.equals(username));
    }

    public void displayAllProfiles() {
        for (int i = 0; i < TABLE_SIZE; i++) {
            if (!table[i].isEmpty()) {
                System.out.println("Index " + i + ":");
                for (UserProfile profile : table[i]) {
                    System.out.println(profile);
                    System.out.println("------------");
                }
            }
        }
    }
}

public class SocialMediaPlatform {
    public static void main(String[] args) {
        HashTable hashTable = new HashTable();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("Menu:");
            System.out.println("1. Add User Profile");
            System.out.println("2. Retrieve User Profile");
            System.out.println("3. Update User Profile");
            System.out.println("4. Delete User Profile");
            System.out.println("5. Display All Profiles");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 1:
                    System.out.print("Enter Username: ");
                    String username = scanner.nextLine();
                    System.out.print("Enter Post: ");
                    String post = scanner.nextLine();
                    System.out.print("Enter Comment: ");
                    String comment = scanner.nextLine();
                    System.out.print("Enter Preference: ");
                    String preference = scanner.nextLine();
                    UserProfile profile = new UserProfile(username, post, comment, preference);
                    hashTable.addProfile(profile);
                    break;
                case 2:
                    System.out.print("Enter Username to Retrieve: ");
                    String retrieveUsername = scanner.nextLine();
                    UserProfile retrievedProfile = hashTable.getProfile(retrieveUsername);
                    if (retrievedProfile != null) {
                        System.out.println(retrievedProfile);
                    } else {
                        System.out.println("Profile not found.");
                    }
                    break;
                case 3:
                    System.out.print("Enter Username to Update: ");
                    String updateUsername = scanner.nextLine();
                    System.out.print("Enter Updated Post: ");
                    String updatePost = scanner.nextLine();
                    System.out.print("Enter Updated Comment: ");
                    String updateComment = scanner.nextLine();
                    System.out.print("Enter Updated Preference: ");
                    String updatePreference = scanner.nextLine();
                    hashTable.updateProfile(updateUsername, updatePost, updateComment, updatePreference);
                    break;
                case 4:
                    System.out.print("Enter Username to Delete: ");
                    String deleteUsername = scanner.nextLine();
                    hashTable.deleteProfile(deleteUsername);
                    break;
                case 5:
                    hashTable.displayAllProfiles();
                    break;
                case 6:
                    return;
                default:
                    System.out.println("Invalid choice.");
            }
        }
    }
}

Infix to post fix

package Assignment1;
import java.util.Scanner;
import java.util.Stack;

public class InfixToPostfix {

    public static int precedence(char ch) {
        switch (ch) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
        }
        return -1;
    }

    public static String infixToPostfix(String expression) {
        String result = "";
        Stack<Character> stack = new Stack<>();

        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);

            if (Character.isLetterOrDigit(c)) {
                result += c;
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    result += stack.pop();
                }
                stack.pop();
            } else {
                while (!stack.isEmpty() && precedence(c) <= precedence(stack.peek())) {
                    result += stack.pop();
                }
                stack.push(c);
            }
        }

        while (!stack.isEmpty()) {
            result += stack.pop();
        }

        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int choice;

        do {
            System.out.println("\nMenu: ");
            System.out.println("1. Convert Infix to Postfix");
            System.out.println("2. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 1:
                    System.out.print("Enter an infix expression: ");
                    String infixExpression = scanner.nextLine();
                    String postfixExpression = infixToPostfix(infixExpression);
                    System.out.println("Postfix Expression: " + postfixExpression);
                    break;

                case 2:
                    System.out.println("Exiting...");
                    break;

                default:
                    System.out.println("Invalid choice! Please choose again.");
                    break;
            }
        } while (choice != 2);

        scanner.close();
    }
}

Marks using the heap 

package Assignment9;

import java.util.PriorityQueue;
import java.util.Scanner;

public class MarksHeap {

    private PriorityQueue<Integer> minHeap;
    private PriorityQueue<Integer> maxHeap;

    public MarksHeap() {
        minHeap = new PriorityQueue<>();
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
    }

    public void addMarks(int marks) {
        minHeap.add(marks);
        maxHeap.add(marks);
    }

    public int getMaxMarks() {
        return maxHeap.peek();
    }

    public int getMinMarks() {
        return minHeap.peek();
    }

    public static void main(String[] args) {
        MarksHeap marksHeap = new MarksHeap();
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the number of students: ");
        int n = scanner.nextInt();

        System.out.println("Enter the marks of " + n + " students:");
        for (int i = 0; i < n; i++) {
            int marks = scanner.nextInt();
            marksHeap.addMarks(marks);
        }

        System.out.println("Maximum marks obtained: " + marksHeap.getMaxMarks());
        System.out.println("Minimum marks obtained: " + marksHeap.getMinMarks());
    }
}

Phone book application 

import java.util.Scanner;

class Contact {
    String name;
    String phoneNumber;

    public Contact(String name, String phoneNumber) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    @Override
    public String toString() {
        return "Name: " + name + ", Phone Number: " + phoneNumber;
    }
}

class TreeNode {
    Contact contact;
    TreeNode left, right;

    public TreeNode(Contact contact) {
        this.contact = contact;
        this.left = this.right = null;
    }
}

class PhoneBook {
    private TreeNode root;

    public PhoneBook() {
        this.root = null;
    }

    public void insert(String name, String phoneNumber) {
        Contact newContact = new Contact(name, phoneNumber);
        root = insertRec(root, newContact);
        System.out.println("Contact added: " + newContact);
    }

    private TreeNode insertRec(TreeNode root, Contact contact) {
        if (root == null) {
            return new TreeNode(contact);
        }
        if (contact.phoneNumber.compareTo(root.contact.phoneNumber) < 0) {
            root.left = insertRec(root.left, contact);
        } else if (contact.phoneNumber.compareTo(root.contact.phoneNumber) > 0) {
            root.right = insertRec(root.right, contact);
        } else {
            System.out.println("Contact with phone number " + contact.phoneNumber + " already exists.");
        }
        return root;
    }

    public void search(String phoneNumber) {
        TreeNode result = searchRec(root, phoneNumber);
        if (result != null) {
            System.out.println("Contact found: " + result.contact);
        } else {
            System.out.println("Contact with phone number " + phoneNumber + " not found.");
        }
    }

    private TreeNode searchRec(TreeNode root, String phoneNumber) {
        if (root == null || root.contact.phoneNumber.equals(phoneNumber)) {
            return root;
        }
        if (phoneNumber.compareTo(root.contact.phoneNumber) < 0) {
            return searchRec(root.left, phoneNumber);
        }
        return searchRec(root.right, phoneNumber);
    }

    public void update(String phoneNumber, String newName) {
        TreeNode result = searchRec(root, phoneNumber);
        if (result != null) {
            result.contact.name = newName;
            System.out.println("Contact updated: " + result.contact);
        } else {
            System.out.println("Contact with phone number " + phoneNumber + " not found.");
        }
    }

    public void delete(String phoneNumber) {
        root = deleteRec(root, phoneNumber);
    }

    private TreeNode deleteRec(TreeNode root, String phoneNumber) {
        if (root == null) {
            System.out.println("Contact with phone number " + phoneNumber + " not found.");
            return root;
        }
        if (phoneNumber.compareTo(root.contact.phoneNumber) < 0) {
            root.left = deleteRec(root.left, phoneNumber);
        } else if (phoneNumber.compareTo(root.contact.phoneNumber) > 0) {
            root.right = deleteRec(root.right, phoneNumber);
        } else {
            if (root.left == null) {
                System.out.println("Contact deleted: " + root.contact);
                return root.right;
            } else if (root.right == null) {
                System.out.println("Contact deleted: " + root.contact);
                return root.left;
            }
            TreeNode minNode = findMin(root.right);
            root.contact = minNode.contact;
            root.right = deleteRec(root.right, minNode.contact.phoneNumber);
        }
        return root;
    }

    private TreeNode findMin(TreeNode root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }

    public void displayContacts() {
        if (root == null) {
            System.out.println("No contacts in phone book.");
        } else {
            System.out.println("Contacts in phone book:");
            inorderTraversal(root);
        }
    }

    private void inorderTraversal(TreeNode root) {
        if (root != null) {
            inorderTraversal(root.left);
            System.out.println(root.contact);
            inorderTraversal(root.right);
        }
    }
}

public class PhoneBookApplication {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PhoneBook phoneBook = new PhoneBook();
        int choice;

        do {
            System.out.println("\nPhone Book Menu:");
            System.out.println("1. Add Contact");
            System.out.println("2. Search Contact");
            System.out.println("3. Update Contact");
            System.out.println("4. Delete Contact");
            System.out.println("5. Display All Contacts");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();
            scanner.nextLine();  // Consume newline

            switch (choice) {
                case 1:
                    System.out.print("Enter name: ");
                    String name = scanner.nextLine();
                    System.out.print("Enter phone number: ");
                    String phoneNumber = scanner.nextLine();
                    phoneBook.insert(name, phoneNumber);
                    break;
                case 2:
                    System.out.print("Enter phone number to search: ");
                    phoneNumber = scanner.nextLine();
                    phoneBook.search(phoneNumber);
                    break;
                case 3:
                    System.out.print("Enter phone number to update: ");
                    phoneNumber = scanner.nextLine();
                    System.out.print("Enter new name: ");
                    name = scanner.nextLine();
                    phoneBook.update(phoneNumber, name);
                    break;
                case 4:
                    System.out.print("Enter phone number to delete: ");
                    phoneNumber = scanner.nextLine();
                    phoneBook.delete(phoneNumber);
                    break;
                case 5:
                    phoneBook.displayContacts();
                    break;
                case 6:
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice! Please try again.");
            }
        } while (choice != 6);

        scanner.close();
    }
}



krushkals algo 


import java.util.*;

class Edge implements Comparable<Edge> {
    int src, dest, wt;

    Edge(int src, int dest, int wt) {
        this.src = src;
        this.dest = dest;
        this.wt = wt;
    }

    public int compareTo(Edge other) {
        return this.wt - other.wt;
    }
}

public class kruskal {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter number of vertices:");
        int v = scanner.nextInt();
        List<Edge> edges = new ArrayList<>();

        while (true) {
            System.out.println("Menu:");
            System.out.println("1. Add an edge");
            System.out.println("2. Calculate MST and total cost");
            System.out.println("3. Exit");
            System.out.print("Choose an option: ");
            int choice = scanner.nextInt();

            if (choice == 1) {
                System.out.print("Enter source vertex: ");
                int src = scanner.nextInt();
                System.out.print("Enter destination vertex: ");
                int dest = scanner.nextInt();
                System.out.print("Enter weight of the edge: ");
                int wt = scanner.nextInt();
                edges.add(new Edge(src, dest, wt));
            } else if (choice == 2) {
                runKruskal(v, edges);
            } else if (choice == 3) {
                System.out.println("Exiting...");
                break;
            } else {
                System.out.println("Invalid choice, please try again.");
            }
        }

        scanner.close();
    }

    static void runKruskal(int v, List<Edge> edges) {
        Collections.sort(edges);

        int[] parent = new int[v];
        int[] rank = new int[v];
        for (int i = 0; i < v; i++) {
            parent[i] = i;
            rank[i] = 0;
        }

        List<Edge> mst = new ArrayList<>();
        int mstCost = 0;

        for (Edge edge : edges) {
            int root1 = find(parent, edge.src);
            int root2 = find(parent, edge.dest);

            if (root1 != root2) {
                mst.add(edge);
                mstCost += edge.wt;
                union(parent, rank, root1, root2);
            }
        }

        System.out.println("Edges in the Minimum Spanning Tree:");
        for (Edge edge : mst) {
            System.out.println(edge.src + " -- " + edge.dest + " == " + edge.wt);
        }
        System.out.println("Total cost of MST: " + mstCost);
    }

    static int find(int[] parent, int node) {
        if (parent[node] != node) {
            parent[node] = find(parent, parent[node]);
        }
        return parent[node];
    }

    static void union(int[] parent, int[]    rank, int root1, int root2) {
        if (rank[root1] < rank[root2]) {
            parent[root1] = root2;
        } else if (rank[root1] > rank[root2]) {
            parent[root2] = root1;
        } else {
            parent[root2] = root1;
            rank[root1]++;
        }
    }
}




MST


import java.util.*;

public class main2 {
    // Function to find the sum of weights of edges in the Minimum Spanning Tree
    static int mst(int v, ArrayList<ArrayList<ArrayList<Integer>>> adj) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // Min-heap for Prim's algorithm
        boolean[] visited = new boolean[v]; // Visited array
        pq.add(new int[]{0, 0, -1}); // Start with node 0, cost 0, and no parent (-1)
        int sum = 0;

        List<int[]> mstEdges = new ArrayList<>(); // To store the edges in the MST

        while (!pq.isEmpty()) {
            int[] curr = pq.remove();
            int currdis = curr[0]; // Current distance (edge weight)
            int node = curr[1];   // Current node
            int parent = curr[2]; // Parent of the current node

            if (visited[node]) continue; // Skip if already visited
            visited[node] = true;       // Mark as visited
            sum += currdis;             // Add the edge weight to MST sum

            // Add the edge to the MST list, except for the starting node
            if (parent != -1) {
                mstEdges.add(new int[]{parent, node, currdis});
            }

            // Iterate over neighbors of the current node
            for (int i = 0; i < adj.get(node).size(); i++) {
                ArrayList<Integer> neigh = adj.get(node).get(i); // Get the neighbor
                int adjNode = neigh.get(0);                     // Adjacent node
                int edgeWeight = neigh.get(1);                  // Edge weight
                if (!visited[adjNode]) {
                    pq.add(new int[]{edgeWeight, adjNode, node});
                }
            }
        }

        // Display the edges of the MST
        System.out.println("Edges in the MST:");
        for (int[] edge : mstEdges) {
            System.out.println("Source: " + edge[0] + " -> Destination: " + edge[1] + " | Weight: " + edge[2]);
        }

        return sum;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayList<ArrayList<ArrayList<Integer>>> adj = new ArrayList<>();
        int vertices = 0;

        while (true) {
            System.out.println("\nMenu:");
            System.out.println("1. Create Graph");
            System.out.println("2. Add Edge");
            System.out.println("3. Calculate MST");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter number of vertices: ");
                    vertices = scanner.nextInt();
                    adj.clear();
                    for (int i = 0; i < vertices; i++) {
                        adj.add(new ArrayList<>());
                    }
                    System.out.println("Graph created with " + vertices + " vertices.");
                    break;

                case 2:
                    if (vertices == 0) {
                        System.out.println("Please create the graph first!");
                        break;
                    }
                    System.out.print("Enter source, destination, and weight of the edge: ");
                    int source = scanner.nextInt();
                    int destination = scanner.nextInt();
                    int weight = scanner.nextInt();

                    // Adding edge to adjacency list
                    ArrayList<Integer> edge1 = new ArrayList<>();
                    edge1.add(destination);
                    edge1.add(weight);
                    adj.get(source).add(edge1);

                    ArrayList<Integer> edge2 = new ArrayList<>();
                    edge2.add(source);
                    edge2.add(weight);
                    adj.get(destination).add(edge2);

                    System.out.println("Edge added: (" + source + ", " + destination + ", " + weight + ")");
                    break;

                case 3:
                    if (vertices == 0) {
                        System.out.println("Please create the graph first!");
                        break;
                    }
                    if (adj.isEmpty()) {
                        System.out.println("No edges added. Please add edges first!");
                        break;
                    }
                    int sum = mst(vertices, adj);
                    System.out.println("Total weight of MST: " + sum);
                    break;

                case 4:
                    System.out.println("Exiting...");
                    scanner.close();
                    return;

                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}



min heap 

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

class MinHeap {
    private ArrayList<Integer> heap;

    public MinHeap() {
        heap = new ArrayList<>();
    }

    // Insert a value into the heap
    public void insert(int value) {
        heap.add(value); // Add the value at the end
        int index = heap.size() - 1;

        // Heapify up to maintain the Min Heap property
        while (index > 0) {
            int parentIndex = (index - 1) / 2;

            if (heap.get(index) >= heap.get(parentIndex)) {
                break;
            }

            // Simplified swap using Collections.swap
            Collections.swap(heap, index, parentIndex);

            index = parentIndex;
        }
    }

    // Get the minimum value (root of the heap)
    public int getMinimum() {
        if (heap.isEmpty()) {
            System.out.println("Heap is Empty");
        }
        return heap.get(0);
    }

    // Get the maximum value by scanning the heap
    public int getMaximum() {
        if (heap.isEmpty()) {
            System.out.println("Heap is empty");
        }
        int max = Integer.MIN_VALUE;
        for (int value : heap) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    // Display the heap elements
    public void displayHeap() {
        if (heap.isEmpty()) {
            System.out.println("Heap is empty!");
        } else {
            System.out.println("Heap elements: " + heap);
        }
    }
}

public class MinHeapMenu {
    public static void main(String[] args) {
        MinHeap minHeap = new MinHeap();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("\n--- Menu ---");
            System.out.println("1. Insert marks");
            System.out.println("2. Find minimum marks");
            System.out.println("3. Find maximum marks");
            System.out.println("4. Display heap");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter the marks to insert: ");
                    int marks = scanner.nextInt();
                    minHeap.insert(marks);
                    System.out.println("Marks added to the heap.");
                    break;

                case 2:
                    try {
                        System.out.println("Minimum marks: " + minHeap.getMinimum());
                    } catch (IllegalStateException e) {
                        System.out.println(e.getMessage());
                    }
                    break;

                case 3:
                    try {
                        System.out.println("Maximum marks: " + minHeap.getMaximum());
                    } catch (IllegalStateException e) {
                        System.out.println(e.getMessage());
                    }
                    break;

                case 4:
                    minHeap.displayHeap();
                    break;

                case 5:
                    System.out.println("Exiting program...");
                    scanner.close();
                    System.exit(0);

                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}



max heap 
import java.util.*;

class MaxHeap {
    private ArrayList<Integer> heap;

    public MaxHeap() {
        heap = new ArrayList<>();
    }

    // Insert a value into the heap
    public void insert(int value) {
        heap.add(value); // Add the value at the end
        heapifyUp(heap.size() - 1); // Heapify up to maintain the Max Heap property
    }

    // Heapify up to maintain the heap property
    private void heapifyUp(int index) {
        while (index > 0) {
            int parentIndex = (index - 1) / 2;
            if (heap.get(index) <= heap.get(parentIndex)) {
                break;
            }
            // Swap using a temporary variable
            Collections.swap(heap, index, parentIndex);
            index = parentIndex;
        }
    }

    // Get the maximum value (root of the heap)
    public int getMaximum() {
        if (heap.isEmpty()) {
            System.out.println("Heap is empty");
            return -1;
        }
        return heap.get(0);
    }

    // Get the minimum value by scanning the heap
    public int getMinimum() {
        if (heap.isEmpty()) {
            System.out.println("Heap is empty");
            return -1;
        }
        int min = Integer.MAX_VALUE;
        for (int value : heap) {
            if (value < min) {
                min = value;
            }
        }
        return min;
    }

    // Display the heap elements
    public void displayHeap() {
        if (heap.isEmpty()) {
            System.out.println("Heap is empty!");
        } else {
            System.out.println("Heap elements: " + heap);
        }
    }
}

public class MaxHeapMenu {
    public static void main(String[] args) {
        MaxHeap maxHeap = new MaxHeap();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("\n--- Menu ---");
            System.out.println("1. Insert marks");
            System.out.println("2. Find maximum marks");
            System.out.println("3. Find minimum marks");
            System.out.println("4. Display heap");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter the marks to insert: ");
                    int marks = scanner.nextInt();
                    maxHeap.insert(marks);
                    System.out.println("Marks added to the heap.");
                    break;

                case 2:
                    System.out.println("Maximum marks: " + maxHeap.getMaximum());
                    break;

                case 3:
                    System.out.println("Minimum marks: " + maxHeap.getMinimum());
                    break;

                case 4:
                    maxHeap.displayHeap();
                    break;

                case 5:
                    System.out.println("Exiting program...");
                    scanner.close();
                    System.exit(0);

                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}



threaded b tree 


import java.util.Scanner;

// Class representing a node in the threaded binary tree
class ThreadedNode {
    int data;
    ThreadedNode left, right;
    boolean leftThread, rightThread;

    public ThreadedNode(int data) {
        this.data = data;
        left = right = null;    
        leftThread = rightThread = false;
    }
}

// Class representing the threaded binary tree
class ThreadedBinaryTree {
    private ThreadedNode root;

    public ThreadedBinaryTree() {
        root = null;
    }

    // Insert a new node into the tree
    public void insert(int data) {
        ThreadedNode newNode = new ThreadedNode(data);
        if (root == null) {
            root = newNode;
            return;
        }

        ThreadedNode current = root;
        ThreadedNode parent = null;

        while (current != null) {
            parent = current;
            if (data < current.data) {
                if (!current.leftThread) {
                    current = current.left; // Move left
                } else {
                    break; // Found position for new node
                }
            } else {
                if (!current.rightThread) {
                    current = current.right; // Move right
                } else {
                    break; // Found position for new node
                }
            }
        }

        // Insert new node
        if (data < parent.data) {
            newNode.left = parent.left;  // Maintain thread to predecessor
            newNode.right = parent;      // Thread to parent
            newNode.leftThread = true;   // Left is a thread
            newNode.rightThread = true;  // Right is a thread
            parent.leftThread = false;   // No longer a thread
            parent.left = newNode;       // Link new node as left child
        } else {
            newNode.right = parent.right; // Maintain thread to successor
            newNode.left = parent;        // Thread to parent
            newNode.leftThread = true;    // Left is a thread
            newNode.rightThread = true;   // Right is a thread
            parent.rightThread = false;   // No longer a thread
            parent.right = newNode;       // Link new node as right child
        }
    }

    // Find the leftmost node in a subtree
    private ThreadedNode leftMost(ThreadedNode node) {
        if (node == null) return null;
        while (!node.leftThread && node.left != null) {
            node = node.left; // Go to the leftmost child
        }
        return node;
    }

    // Inorder traversal using threads
    public void inorderTraversal() {
        ThreadedNode current = leftMost(root);

        while (current != null) {
            System.out.print(current.data + " ");

            if (current.rightThread) {
                current = current.right; // Move to successor via thread
            } else {
                current = leftMost(current.right); // Go to leftmost of right subtree
            }
        }
    }
}

// Main class to demonstrate the threaded binary tree functionality
public class Main {
    public static void main(String[] args) {
        ThreadedBinaryTree tbt = new ThreadedBinaryTree();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("\n--- Menu ---");
            System.out.println("1. Insert a node");
            System.out.println("2. Display inorder traversal");
            System.out.println("3. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter the value to insert: ");
                    int value = scanner.nextInt();
                    tbt.insert(value);
                    System.out.println("Node " + value + " inserted successfully.");
                    break;

                case 2:
                    System.out.println("Inorder Traversal of the Threaded Binary Tree:");
                    tbt.inorderTraversal();
                    System.out.println();
                    break;

                case 3:
                    System.out.println("Exiting program...");
                    scanner.close();
                    System.exit(0);
                    break;

                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}
